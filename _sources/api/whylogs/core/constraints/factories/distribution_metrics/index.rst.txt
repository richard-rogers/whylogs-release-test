:py:mod:`whylogs.core.constraints.factories.distribution_metrics`
=================================================================

.. py:module:: whylogs.core.constraints.factories.distribution_metrics


Module Contents
---------------


Functions
~~~~~~~~~

.. autoapisummary::

   whylogs.core.constraints.factories.distribution_metrics.greater_than_number
   whylogs.core.constraints.factories.distribution_metrics.smaller_than_number
   whylogs.core.constraints.factories.distribution_metrics.is_non_negative
   whylogs.core.constraints.factories.distribution_metrics.is_in_range
   whylogs.core.constraints.factories.distribution_metrics.mean_between_range
   whylogs.core.constraints.factories.distribution_metrics.stddev_between_range
   whylogs.core.constraints.factories.distribution_metrics.quantile_between_range



.. py:function:: greater_than_number(column_name: str, number: Union[float, int], skip_missing: bool = True) -> whylogs.core.constraints.MetricConstraint

   Minimum value of given column must be above defined number.

   :param column_name: Column the constraint is applied to
   :type column_name: str
   :param number: reference value for applying the constraint
   :type number: float
   :param skip_missing: If skip_missing is True, missing distribution metrics will make the check pass.
                        If False, the check will fail on missing metrics, such as on an empty dataset
   :type skip_missing: bool


.. py:function:: smaller_than_number(column_name: str, number: float, skip_missing: bool = True) -> whylogs.core.constraints.MetricConstraint

   Maximum value of given column must be below defined number.

   :param column_name: Column the constraint is applied to
   :type column_name: str
   :param number: reference value for applying the constraint
   :type number: float
   :param skip_missing: If skip_missing is True, missing distribution metrics will make the check pass.
                        If False, the check will fail on missing metrics, such as on an empty dataset
   :type skip_missing: bool


.. py:function:: is_non_negative(column_name: str, skip_missing: bool = True) -> whylogs.core.constraints.MetricConstraint

   Checks if a column is non negative

   :param column_name: Column the constraint is applied to
   :type column_name: str
   :param skip_missing: If skip_missing is True, missing distribution metrics will make the check pass.
                        If False, the check will fail on missing metrics, such as on an empty dataset
   :type skip_missing: bool


.. py:function:: is_in_range(column_name: str, lower: Union[float, int], upper: Union[float, int], skip_missing: bool = True) -> whylogs.core.constraints.MetricConstraint

   Checks that all of column's values are in defined range (inclusive).

   For the constraint to pass, the column's minimum value should be higher or equal than `lower` and maximum value should be less than or equal to `upper`.

   :param column_name: Column the constraint is applied to
   :type column_name: str
   :param lower: lower bound of defined range
   :type lower: float
   :param upper: upper bound of defined range
   :type upper: float
   :param skip_missing: If skip_missing is True, missing distribution metrics will make the check pass.
                        If False, the check will fail on missing metrics, such as on an empty dataset
   :type skip_missing: bool


.. py:function:: mean_between_range(column_name: str, lower: float, upper: float, skip_missing: bool = True) -> whylogs.core.constraints.MetricConstraint

   Estimated mean must be between range defined by lower and upper bounds.

   :param column_name: Column the constraint is applied to
   :type column_name: str
   :param lower: Lower bound of defined range
   :type lower: int
   :param upper: Upper bound of the value range
   :type upper: int
   :param skip_missing: If skip_missing is True, missing distribution metrics will make the check pass.
                        If False, the check will fail on missing metrics, such as on an empty dataset
   :type skip_missing: bool


.. py:function:: stddev_between_range(column_name: str, lower: float, upper: float, skip_missing: bool = True)

   Estimated standard deviation must be between range defined by lower and upper bounds.

   :param column_name: Column the constraint is applied to
   :type column_name: str
   :param lower: Lower bound of defined range
   :type lower: float
   :param upper: Upper bound of the value range
   :type upper: float
   :param skip_missing: If skip_missing is True, missing distribution metrics will make the check pass.
                        If False, the check will fail on missing metrics, such as on an empty dataset
   :type skip_missing: bool


.. py:function:: quantile_between_range(column_name: str, quantile: float, lower: float, upper: float, skip_missing: bool = True) -> whylogs.core.constraints.MetricConstraint

   Q-th quantile value must be withing the range defined by lower and upper boundaries.

   :param column_name: Column the constraint is applied to
   :type column_name: str
   :param quantile: Quantile value. E.g. median is equal to quantile_value=0.5
   :type quantile: float
   :param lower: Lower bound of defined range
   :type lower: float
   :param upper: Upper bound of the value range
   :type upper: float
   :param skip_missing: If skip_missing is True, missing distribution metrics will make the check pass.
                        If False, the check will fail on missing metrics, such as on an empty dataset
   :type skip_missing: bool


